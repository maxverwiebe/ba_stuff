\chapter{Integration of Optimized Clustering into Index Partitioning}
Now all the fundamentals and concepts are in place to integrate $k$-Means clustering and the optimized clustering into the index partitioning process.
The goal is to use the clusters generated by the clustering algorithm as partitions for the R-Tree.
This means that each cluster will be mapped to a partition/MBR of the R-Tree, and the data points in each cluster will be stored in the corresponding partition.

\section{Pipeline Overview}
Given is a set of data points, which are to be clustered and then used to build an R-Tree.
The pipeline consists of the following steps:
\begin{itemize}
    \item Basic clustering: Apply the clustering algorithm to group similar data points.
    \item Optimized clustering (post-processing): Usage of the optimized clustering algorithm to refine the clusters, ensuring a minimal overlap of their bounding boxes.
    \item Partitioning: Map each cluster to a partition/MBR of the R-Tree.
    \item Index Construction: Build the R-Tree using the clustered data.
\end{itemize}
\newline
Figure \ref{fig:optimized_clustering_pipeline} illustrates the overall pipeline for building an R-Tree with optimized clustering.
\newline
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{Images/PIPELINE.png}
    \caption{Pipeline for building an R-Tree with optimized clustering.}
    \label{fig:optimized_clustering_pipeline}
\end{figure}

\section{Basic Clustering}
The first step is to apply the $k$-Means clustering algorithm to the data points.
This will group the data points into $k$ clusters based on their spatial similarity.

\section{Optimizing the Clusters}
The next step is to optimize the $k$ baseline clusters generated by the $k$-Means algorithm.
The goal is to have a minimal overlap of the bounding boxes of the clusters and constraints regarding their {MIN\_POINTS} and {MAX\_POINTS}.
This is achieved by applying the optimized clustering algorithm defined in Section 5.
It finds the best possible partitioning of the data points into clusters, ensuring that the bounding boxes of the clusters do not overlap and that the clusters adhere to the specified size constraints.
This process takes the $k$ baseline clusters and generates $n$ optimized clusters.

\section{Mapping Clusters to R-Tree Partitions}
Once the clusters are optimized, the next step is to calculate their MBRs.
For each optimized cluster $C_i$, we compute its axis-aligned MBR.

\section{Building the R-Tree} \label{sec:r_tree_construction_optimized}
Finally, we build the R-Tree by {incrementally} inserting all points in cluster order. 
The tree is created with leaf capacity equal to {MAX\_POINTS}, so that each cluster maps to a single leaf whenever 
$|C_i| \le \textit{MAX\_POINTS}$ (otherwise to a small bounded number of leaves). 
The parent entry over each leaf adopts the leafâ€™s coverage, which closely matches the cluster MBR. This preserves the intended partitioning, we have created earlier. 
Also, this prevents strong MBR overlaps and improves pruning for $k$NN queries.

\paragraph{Practical note on bulk-loading.}
Standard STR bulk-loading as implemented in common libraries, like the C++ library used for this work, libspatialindex, may internally reorder entries and therefore does not guarantee preservation of externally provided cluster partitions.
That's why this thesis sticks with the incremental insertion of the MBRs and data points.